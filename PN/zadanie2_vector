#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

uint16_t FillArray32MinMax(int32_t array[], int32_t min, int32_t max, uint16_t limit) {
    uint16_t i = 0;
    while(min != max) {
        if(max > min) array[i++] = min++;
        else array[i++] = min--;
        if(!--limit) return 0;
    }
    array[i++] = min;
    return i;
}

uint16_t GetArray32MinMax(int32_t *array[], int32_t min, int32_t max) {
    uint16_t length;
    if(max > min) length = (uint16_t)(max - min + 1);
    else length = (uint16_t)(min - max + 1);
    *array = (int32_t *)malloc(length * sizeof(int32_t));
    if (*array == NULL) return 0;
    return FillArray32MinMax(*array, min, max, length);
}

typedef struct vectorType {
    int32_t *buffer;
    uint16_t length;
} vector_t;

vector_t vectorInit(int32_t min, int32_t max) {
    vector_t vector;
    vector.length = GetArray32MinMax(&vector.buffer, min, max);
    return vector;
}

bool vectorIsSet(vector_t *vector) {
    return (vector != NULL && vector->length > 0 && vector->buffer != NULL);
}


// Wyświetla zawartość wektora w formacie [e1, e2, ...]


void vectorPrint(vector_t *v) {
    if (!vectorIsSet(v)) {
        printf("Vector empty or not set.\n");
        return;
    }
    printf("[ ");
    for (uint16_t i = 0; i < v->length; i++) {
        printf("%d%s", v->buffer[i], (i == v->length - 1) ? "" : ", ");
    }
    printf(" ]\n");
}


// Dodaje nową wartość na koniec wektora (zwiększa rozmiar)

void vectorPush(vector_t *v, int32_t value) {
    int32_t *tmp = (int32_t *)realloc(v->buffer, (v->length + 1) * sizeof(int32_t));
    if (tmp != NULL) {
        v->buffer = tmp;
        v->buffer[v->length] = value;
        v->length++;
    }
}


// Usuwa ostatnią wartość z wektora (zmniejsza rozmiar)

void vectorPop(vector_t *v) {
    if (v->length == 0) return;
    if (v->length == 1) {
        free(v->buffer);
        v->buffer = NULL;
        v->length = 0;
    } else {
        v->length--;
        v->buffer = (int32_t *)realloc(v->buffer, v->length * sizeof(int32_t));
    }
}


// Łączy dwa wektory w jeden nowy wektor

vector_t vectorMerge(vector_t *v1, vector_t *v2) {
    vector_t result = {NULL, 0};
    uint16_t newLen = v1->length + v2->length;
    result.buffer = (int32_t *)malloc(newLen * sizeof(int32_t));
    if (result.buffer) {
        result.length = newLen;
        for (uint16_t i = 0; i < v1->length; i++) result.buffer[i] = v1->buffer[i];
        for (uint16_t i = 0; i < v2->length; i++) result.buffer[v1->length + i] = v2->buffer[i];
    }
    return result;
}


// Sumuje elementy dwóch wektorów
// Muszą mieć tę samą długość, inaczej zwraca pusty wektor

vector_t vectorSum(vector_t *v1, vector_t *v2) {
    vector_t res = {NULL, 0};
    if (v1->length != v2->length) return res;
    res.buffer = (int32_t *)malloc(v1->length * sizeof(int32_t));
    res.length = v1->length;
    for (uint16_t i = 0; i < v1->length; i++) res.buffer[i] = v1->buffer[i] + v2->buffer[i];
    return res;
}


// Odejmuje elementy dwóch wektorów

vector_t vectorDifference(vector_t *v1, vector_t *v2) {
    vector_t res = {NULL, 0};
    if (v1->length != v2->length) return res;
    res.buffer = (int32_t *)malloc(v1->length * sizeof(int32_t));
    res.length = v1->length;
    for (uint16_t i = 0; i < v1->length; i++) res.buffer[i] = v1->buffer[i] - v2->buffer[i];
    return res;
}


// Mnoży elementy dwóch wektorów

vector_t vectorMultiplication(vector_t *v1, vector_t *v2) {
    vector_t res = {NULL, 0};
    if (v1->length != v2->length) return res;
    res.buffer = (int32_t *)malloc(v1->length * sizeof(int32_t));
    res.length = v1->length;
    for (uint16_t i = 0; i < v1->length; i++) res.buffer[i] = v1->buffer[i] * v2->buffer[i];
    return res;
}

int main(void) {
    // Inicjalizacja

    vector_t vecA = vectorInit(1, 5);  // [1, 2, 3, 4, 5]
    vector_t vecB = vectorInit(10, 14); // [10, 11, 12, 13, 14]

    printf("Wektor A: "); vectorPrint(&vecA);
    printf("Wektor B: "); vectorPrint(&vecB);

    // Push i Pop

    printf("\nPush 100 do A i Pop z B:\n");
    vectorPush(&vecA, 100);
    vectorPop(&vecB);
    vectorPrint(&vecA);
    vectorPrint(&vecB);

    // Merge

    printf("\nMerge A i B:\n");
    vector_t merged = vectorMerge(&vecA, &vecB);
    vectorPrint(&merged);

    // Operacje matematyczne (wymagają równej długości)

    vector_t v1 = vectorInit(1, 3); // [1, 2, 3]
    vector_t v2 = vectorInit(4, 6); // [4, 5, 6]
    
    printf("\nOperacje na "); vectorPrint(&v1); printf(" oraz "); vectorPrint(&v2);
    
    vector_t sum = vectorSum(&v1, &v2);
    printf("Suma: "); vectorPrint(&sum);

    vector_t diff = vectorDifference(&v2, &v1);
    printf("Roznica (v2-v1): "); vectorPrint(&diff);

    vector_t mult = vectorMultiplication(&v1, &v2);
    printf("Mnozenie: "); vectorPrint(&mult);

    // Czyszczenie pamięci

    free(vecA.buffer);
    free(vecB.buffer);
    free(merged.buffer);
    free(v1.buffer);
    free(v2.buffer);
    free(sum.buffer);
    free(diff.buffer);
    free(mult.buffer);

    return 0;
}
